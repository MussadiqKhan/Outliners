import{createMemoryHistory,parsePath}from'history';import PropTypes from'prop-types';import{createContext,useRef,createElement,useContext,useEffect,useState,useMemo,useCallback,Children,isValidElement,Fragment,useTransition as useTransition$1}from'react';function h(a,b){if(!a)throw Error(b);}function k(a,b){if(!a){"undefined"!==typeof console&&console.warn(b);try{throw Error(b);}catch(c){}}}let m=createContext({history:null,location:null,pending:!1,static:!1});m.displayName="Location";let n=createContext({outlet:null,params:Object.freeze({}),pathname:"",route:null});n.displayName="Route";
function p({children:a,initialEntries:b,initialIndex:c,timeout:d}){let e=useRef(null);null==e.current&&(e.current=createMemoryHistory({initialEntries:b,initialIndex:c}));return createElement(r,{children:a,history:e.current,timeout:d})}p.displayName="MemoryRouter";
p.propTypes={children:PropTypes.node,timeout:PropTypes.number,initialEntries:PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string,PropTypes.shape({pathname:PropTypes.string,search:PropTypes.string,hash:PropTypes.string,state:PropTypes.object,key:PropTypes.string})])),initialIndex:PropTypes.number};
function t({to:a,replace:b,state:c}){u()?void 0:h(!1,"<Navigate> may be used only in the context of a <Router> component.");let d=useContext(m);k(!d.static,"<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.");let e=v();useEffect(()=>{e(a,{replace:b,state:c})});return null}t.displayName="Navigate";
t.propTypes={to:PropTypes.oneOfType([PropTypes.string,PropTypes.shape({pathname:PropTypes.string,search:PropTypes.string,hash:PropTypes.string})]).isRequired,replace:PropTypes.bool,state:PropTypes.object};function w(){return x()}w.displayName="Outlet";w.propTypes={};function y({element:a=createElement(w,null)}){return a}y.displayName="Route";y.propTypes={children:PropTypes.node,element:PropTypes.element,path:PropTypes.string};let z=a=>a(),A=useTransition$1||(()=>[z,!1]);
function r({children:a=null,history:b,static:c=!1,timeout:d=2E3}){u()?h(!1,"You cannot render a <Router> inside another <Router>. You never need more than one."):void 0;let [e,g]=useState(b.location),[f,l]=A({timeoutMs:d});d=useRef(!c);d.current&&(d.current=!1,b.listen(({location:b})=>{f(()=>{g(b)})}));return createElement(m.Provider,{children:a,value:{history:b,location:e,pending:l,static:c}})}r.displayName="Router";
r.propTypes={children:PropTypes.node,history:PropTypes.shape({action:PropTypes.string,location:PropTypes.object,push:PropTypes.func,replace:PropTypes.func,go:PropTypes.func,listen:PropTypes.func,block:PropTypes.func}),timeout:PropTypes.number};function B({basename:a="",children:b}){b=C(b);return D(b,a)}B.displayName="Routes";B.propTypes={basename:PropTypes.string,caseSensitive:PropTypes.bool,children:PropTypes.node};function u(){return null!=useContext(m).location}
function E(){u()?void 0:h(!1,"useLocation() may be used only in the context of a <Router> component.");return useContext(m).location}
function v(){u()?void 0:h(!1,"useNavigate() may be used only in the context of a <Router> component.");let a=useContext(m),b=a.history,c=a.pending,{pathname:d}=useContext(n),e=useRef(!1);useEffect(()=>{e.current=!0});return useCallback((a,f={})=>{e.current?"number"===typeof a?b.go(a):(a=F(a,d),(f.replace||c?b.replace:b.push)(a,f.state)):k(!1,"You should call navigate() in a useEffect, not when your component is first rendered.")},[b,d,c])}function x(){return useContext(n).outlet}
function G(a){let {pathname:b}=useContext(n);return useMemo(()=>F(a,b),[a,b])}let H={};function I(a,b,c){b||H[a]||(H[a]=!0,k(!1,c))}
function D(a,b=""){let {route:c,pathname:d,params:e}=useContext(n);var g=c&&c.path;I(d,!c||c.path.endsWith("*"),`You rendered descendant <Routes> (or called \`useRoutes\`) at "${d}"`+` (under <Route path="${g}">) but the parent route path has no trailing "*".`+" This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.\n\n"+`Please change the parent <Route path="${g}"> to <Route path="${g}/*">.`);b=b?[d,b].join("/").replace(/\/\/+/g,"/"):d;
let f=E();return(g=useMemo(()=>J(a,f,b),[f,a,b]))?g.reduceRight((a,{params:c,pathname:d,route:f})=>createElement(n.Provider,{children:f.element,value:{outlet:a,params:Object.freeze({...e,...c}),pathname:[b,d].join("/").replace(/\/\/+/g,"/"),route:f}}),null):null}function K(a){return a.map(b=>{let a={caseSensitive:!0===b.caseSensitive,element:b.element||createElement(w,null),path:b.path||"/"};b.children&&(a.children=K(b.children));return a})}
function C(a){let b=[];Children.forEach(a,a=>{if(isValidElement(a))if(a.type===Fragment)b.push.apply(b,C(a.props.children));else{var c={caseSensitive:!0===a.props.caseSensitive,element:a,path:a.props.path||"/"};a.props.children&&(a=C(a.props.children),a.length&&(c.children=a));b.push(c)}});return b}
function J(a,b,c=""){"string"===typeof b&&(b=parsePath(b));b=b.pathname||"/";if(c)if(c=c.replace(/^\/*/,"/").replace(/\/+$/,""),b.startsWith(c))b=b===c?"/":b.slice(c.length);else return null;a=L(a);M(a);var d=null;for(c=0;null==d&&c<a.length;++c)a:{d=b;let g=a[c][1],f="/",l={},q=[];for(let a=0;a<g.length;++a){let b=g[a];var e="/"===f?d:d.slice(f.length)||"/";e=N({path:b.path,caseSensitive:b.caseSensitive,end:a===g.length-1},e);if(!e){d=null;break a}f=[f,e.pathname].join("/").replace(/\/\/+/g,"/");
l={...l,...e.params};q.push({route:b,pathname:f,params:Object.freeze(l)})}d=q}return d}function L(a,b=[],c="",d=[],e=[]){a.forEach((a,f)=>{let g=[c,a.path].join("/").replace(/\/\/+/g,"/"),q=d.concat(a);f=e.concat(f);a.children&&L(a.children,b,g,q,f);b.push([g,q,f])});return b}function M(a){let b=a.reduce((a,[b])=>{a[b]=O(b);return a},{});P(a,(a,d)=>{let [c,,g]=a;a=b[c];let [f,,l]=d;d=b[f];return a!==d?d-a:Q(g,l)})}let R=/^:\w+$/,S=a=>"*"===a;
function O(a){a=a.split("/");let b=a.length;a.some(S)&&(b+=-2);return a.filter(a=>"*"!==a).reduce((a,b)=>a+(R.test(b)?2:""===b?1:10),b)}function Q(a,b){return a.length===b.length&&a.slice(0,-1).every((a,d)=>a===b[d])?a[a.length-1]-b[b.length-1]:0}function P(a,b){let c=a.slice(0);a.sort((a,e)=>b(a,e)||c.indexOf(a)-c.indexOf(e))}
function N(a,b){"string"===typeof a&&(a={path:a});let {path:c,caseSensitive:d=!1,end:e=!0}=a,[g,f]=T(c,d,e);b=b.match(g);if(!b)return null;a=b[1];let l=b.slice(2);b=f.reduce((a,b,c)=>{c=l[c];try{var d=decodeURIComponent(c.replace(/\+/g," "))}catch(U){k(!1,`The value for the URL param "${b}" will not be decoded because`+` the string "${c}" is a malformed URL segment. This is probably`+` due to a bad percent encoding (${U}).`),d=c}a[b]=d;return a},{});return{path:c,pathname:a,params:b}}
function T(a,b,c){let d=[],e="^("+a.replace(/^\/*/,"/").replace(/\/?\*?$/,"").replace(/[\\.*+^$?{}|()[\]]/g,"\\$&").replace(/:(\w+)/g,(a,b)=>{d.push(b);return"([^\\/]+)"})+")";a.endsWith("*")?(a.endsWith("/*")&&(e+="\\/?"),d.push("*"),e+="(.*)"):c&&(e+="\\/?");c&&(e+="$");return[new RegExp(e,b?void 0:"i"),d]}function F(a,b="/"){let {pathname:c,search:d="",hash:e=""}="string"===typeof a?parsePath(a):a;return{pathname:c?V(c,c.startsWith("/")?"/":b):b,search:d,hash:e}}
function V(a,b){let c=b.replace(/\/+$/,"").replace(/\/\/+/g,"/").split("/");a.replace(/\/\/+/g,"/").split("/").forEach(a=>{".."===a?1<c.length&&c.pop():"."!==a&&c.push(a)});return 1<c.length?c.join("/").replace(/\/\/+/g,"/"):"/"}
function generatePath(a,b={}){return a.replace(/:(\w+)/g,(a,d)=>b[d]||`:${d}`).replace(/\*$/,a=>b[a]||a)};function useBlocker(a,b=!0){u()?void 0:h(!1,"useBlocker() may be used only in the context of a <Router> component.");let c=useContext(m).history;useEffect(()=>{if(b){var d=c.block(b=>{a({...b,retry(){d();b.retry()}})});return d}},[c,b,a])};
function useHref(a){u()?void 0:h(!1,"useHref() may be used only in the context of a <Router> component.");let b=useContext(m).history;a=G(a);return b.createHref(a)};function useLocationPending(){return useContext(m).pending};function useMatch(a){u()?void 0:h(!1,"useMatch() may be used only in the context of a <Router> component.");let b=E();return N(a,b.pathname)};function useParams(){return useContext(n).params};
function useRoutes(a,b=""){u()?void 0:h(!1,"useRoutes() may be used only in the context of a <Router> component.");let c=useMemo(()=>K(a),[a]);return D(c,b)};export{p as MemoryRouter,t as Navigate,w as Outlet,y as Route,r as Router,B as Routes,K as createRoutesFromArray,C as createRoutesFromChildren,generatePath,N as matchPath,J as matchRoutes,F as resolveLocation,useBlocker,useHref,u as useInRouterContext,E as useLocation,useLocationPending,useMatch,v as useNavigate,x as useOutlet,useParams,G as useResolvedLocation,useRoutes}
//# sourceMappingURL=react-router.development.js.map
